/* tslint:disable */
/* eslint-disable */
/**
 * Edison Backend API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AdminPaymentProduct,
  Archetype,
  ArchetypeIndex,
  Article,
  Author,
  AuthorRole,
  AuthorSetting,
  AuthorStatus,
  CategoryInfo,
  Characteristic,
  Dashboard,
  EngineInfo,
  GlobalScore,
  Info,
  InvoiceType,
  ManuscriptUploadResponse,
  ModelResultData,
  PageOfAdminPaymentProduct,
  PageOfAuthor,
  PageOfDetailedHistoryEvent,
  PageOfHistoryEvent,
  PageOfInvoice,
  PageOfManuscript,
  PageOfManuscriptRevision,
  PageOfPurchase,
  PageOfSubscription,
  PaymentProduct,
  PaymentProductType,
  Purchase,
  PurchaseInitiationResult,
  PurchaseStatus,
  Recommendation,
  ReportIndex,
  SimilarBookMetadata,
  Text,
  Tip,
  WhatIs,
} from '../models';

export interface AdminChangeManuscriptRevisionTitleRequest {
    manuscriptId: string;
    revisionId: string;
    newTitle: string;
    reason: string;
    additionalReason?: string;
}

export interface AdminChangeManuscriptTitleRequest {
    manuscriptId: string;
    newTitle: string;
}

export interface AdminDeleteManuscriptRequest {
    manuscriptId: string;
    reason: string;
    additionalReason?: string;
}

export interface AdminDeleteManuscriptRevisionRequest {
    manuscriptId: string;
    revisionId: string;
    reason: string;
    additionalReason?: string;
}

export interface AdminGetAnalyzedDataRequest {
    manuscriptId: string;
    revisionId: string;
    models?: string;
    sections?: string;
}

export interface AdminGetAuthorRequest {
    authorId: string;
}

export interface AdminGetAuthorHistoryRequest {
    authorId: string;
    startTime?: string;
    endTime?: string;
    page?: number;
    pageSize?: number;
}

export interface AdminGetAuthorsRequest {
    email?: string;
    roles?: string;
    page?: number;
    pageSize?: number;
    sortBy?: AdminGetAuthorsSortByEnum;
}

export interface AdminGetManuscriptRevisionsRequest {
    manuscriptId: string;
    page?: number;
    pageSize?: number;
}

export interface AdminGetManuscriptsRequest {
    authorId?: string;
    sortBy?: AdminGetManuscriptsSortByEnum;
    page?: number;
    pageSize?: number;
}

export interface AdminSetRoleRequest {
    authorId: string;
    newRole: AuthorRole;
}

export interface ChangeManuscriptRevisionTitleRequest {
    manuscriptId: string;
    revisionId: string;
    newTitle: string;
}

export interface ChangeManuscriptTitleRequest {
    manuscriptId: string;
    newTitle: string;
}

export interface CreatePurchaseRequest {
    productId: string;
}

export interface DeleteManuscriptRequest {
    manuscriptId: string;
    reason: string;
    additionalReason?: string;
}

export interface DeleteManuscriptRevisionRequest {
    manuscriptId: string;
    revisionId: string;
}

export interface DeleteSettingRequest {
    name: string;
}

export interface DeleteTextRequest {
    language: string;
    name: string;
}

export interface GetAdminPaymentProductsRequest {
    page?: number;
    pageSize?: number;
}

export interface GetAnalyzedDataRequest {
    manuscriptId: string;
    revisionId: string;
    models?: string;
    sections?: string;
}

export interface GetArticlesRequest {
    report: number;
}

export interface GetCharacteristicRequest {
    report: number;
}

export interface GetHistoryRequest {
    startTime?: string;
    endTime?: string;
    page?: number;
    pageSize?: number;
}

export interface GetInvoicesRequest {
    type?: InvoiceType;
    startTime?: string;
    endTime?: string;
    page?: number;
    pageSize?: number;
}

export interface GetManuscriptRevisionsRequest {
    manuscriptId: string;
    page?: number;
    pageSize?: number;
}

export interface GetManuscriptsRequest {
    page?: number;
    pageSize?: number;
}

export interface GetPurchaseRequest {
    clientReferenceId: string;
}

export interface GetPurchasesRequest {
    status?: PurchaseStatus;
    productType?: PaymentProductType;
    startTime?: string;
    endTime?: string;
    page?: number;
    pageSize?: number;
}

export interface GetRecommendationRequest {
    metricId: number;
    genre: string;
    audience: string;
    metricValue: number;
}

export interface GetSimilarBookDataRequest {
    isbn: number;
    models?: string;
    sections?: string;
}

export interface GetSimilarBookMetadataRequest {
    isbn: number;
}

export interface GetSimilarBookTrialReportDataRequest {
    models?: string;
    sections?: string;
}

export interface GetSimilarBookTrialReportMetadataRequest {
    isbn: number;
}

export interface GetSubscriptionsRequest {
    page?: number;
    pageSize?: number;
}

export interface GetTextsRequest {
    language: string;
    names?: string;
}

export interface GetTipsRequest {
    report: number;
}

export interface SavePaymentProductRequest {
    adminPaymentProduct?: AdminPaymentProduct;
}

export interface SaveSettingsRequest {
    authorSetting?: Array<AuthorSetting>;
}

export interface SaveTextRequest {
    language: string;
    name: string;
    text: string;
}

export interface SetAuthorEmailRequest {
    email: string;
}

export interface UploadManuscriptRequest {
    manuscriptTitle: string;
    targetAudience: string;
    targetGenre: string;
    fileType: UploadManuscriptFileTypeEnum;
    file: Blob;
    revisionTitle?: string;
}

export interface UploadManuscriptRevisionRequest {
    manuscriptId: string;
    targetAudience: string;
    targetGenre: string;
    fileType: UploadManuscriptRevisionFileTypeEnum;
    file: Blob;
    revisionTitle?: string;
}

/**
 * 
 */
export class DefaultApi extends runtime.BaseAPI {

    /**
     * Change the title of a manuscript revision
     */
    async adminChangeManuscriptRevisionTitleRaw(requestParameters: AdminChangeManuscriptRevisionTitleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.manuscriptId === null || requestParameters.manuscriptId === undefined) {
            throw new runtime.RequiredError('manuscriptId','Required parameter requestParameters.manuscriptId was null or undefined when calling adminChangeManuscriptRevisionTitle.');
        }

        if (requestParameters.revisionId === null || requestParameters.revisionId === undefined) {
            throw new runtime.RequiredError('revisionId','Required parameter requestParameters.revisionId was null or undefined when calling adminChangeManuscriptRevisionTitle.');
        }

        if (requestParameters.newTitle === null || requestParameters.newTitle === undefined) {
            throw new runtime.RequiredError('newTitle','Required parameter requestParameters.newTitle was null or undefined when calling adminChangeManuscriptRevisionTitle.');
        }

        if (requestParameters.reason === null || requestParameters.reason === undefined) {
            throw new runtime.RequiredError('reason','Required parameter requestParameters.reason was null or undefined when calling adminChangeManuscriptRevisionTitle.');
        }

        const queryParameters: any = {};

        if (requestParameters.newTitle !== undefined) {
            queryParameters['newTitle'] = requestParameters.newTitle;
        }

        if (requestParameters.reason !== undefined) {
            queryParameters['reason'] = requestParameters.reason;
        }

        if (requestParameters.additionalReason !== undefined) {
            queryParameters['additionalReason'] = requestParameters.additionalReason;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/admin/manuscripts/{manuscriptId}/revisions/{revisionId}/title`.replace(`{${"manuscriptId"}}`, encodeURIComponent(String(requestParameters.manuscriptId))).replace(`{${"revisionId"}}`, encodeURIComponent(String(requestParameters.revisionId))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Change the title of a manuscript revision
     */
    async adminChangeManuscriptRevisionTitle(requestParameters: AdminChangeManuscriptRevisionTitleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.adminChangeManuscriptRevisionTitleRaw(requestParameters, initOverrides);
    }

    /**
     * Change the title of a manuscript
     */
    async adminChangeManuscriptTitleRaw(requestParameters: AdminChangeManuscriptTitleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.manuscriptId === null || requestParameters.manuscriptId === undefined) {
            throw new runtime.RequiredError('manuscriptId','Required parameter requestParameters.manuscriptId was null or undefined when calling adminChangeManuscriptTitle.');
        }

        if (requestParameters.newTitle === null || requestParameters.newTitle === undefined) {
            throw new runtime.RequiredError('newTitle','Required parameter requestParameters.newTitle was null or undefined when calling adminChangeManuscriptTitle.');
        }

        const queryParameters: any = {};

        if (requestParameters.newTitle !== undefined) {
            queryParameters['newTitle'] = requestParameters.newTitle;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/admin/manuscripts/{manuscriptId}/title`.replace(`{${"manuscriptId"}}`, encodeURIComponent(String(requestParameters.manuscriptId))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Change the title of a manuscript
     */
    async adminChangeManuscriptTitle(requestParameters: AdminChangeManuscriptTitleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.adminChangeManuscriptTitleRaw(requestParameters, initOverrides);
    }

    /**
     * deletes the manuscript with the given id
     */
    async adminDeleteManuscriptRaw(requestParameters: AdminDeleteManuscriptRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.manuscriptId === null || requestParameters.manuscriptId === undefined) {
            throw new runtime.RequiredError('manuscriptId','Required parameter requestParameters.manuscriptId was null or undefined when calling adminDeleteManuscript.');
        }

        if (requestParameters.reason === null || requestParameters.reason === undefined) {
            throw new runtime.RequiredError('reason','Required parameter requestParameters.reason was null or undefined when calling adminDeleteManuscript.');
        }

        const queryParameters: any = {};

        if (requestParameters.reason !== undefined) {
            queryParameters['reason'] = requestParameters.reason;
        }

        if (requestParameters.additionalReason !== undefined) {
            queryParameters['additionalReason'] = requestParameters.additionalReason;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/admin/manuscripts/{manuscriptId}`.replace(`{${"manuscriptId"}}`, encodeURIComponent(String(requestParameters.manuscriptId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * deletes the manuscript with the given id
     */
    async adminDeleteManuscript(requestParameters: AdminDeleteManuscriptRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.adminDeleteManuscriptRaw(requestParameters, initOverrides);
    }

    /**
     * deletes the manuscript with the given id (dangerous - does not check ownership)
     */
    async adminDeleteManuscriptRevisionRaw(requestParameters: AdminDeleteManuscriptRevisionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.manuscriptId === null || requestParameters.manuscriptId === undefined) {
            throw new runtime.RequiredError('manuscriptId','Required parameter requestParameters.manuscriptId was null or undefined when calling adminDeleteManuscriptRevision.');
        }

        if (requestParameters.revisionId === null || requestParameters.revisionId === undefined) {
            throw new runtime.RequiredError('revisionId','Required parameter requestParameters.revisionId was null or undefined when calling adminDeleteManuscriptRevision.');
        }

        if (requestParameters.reason === null || requestParameters.reason === undefined) {
            throw new runtime.RequiredError('reason','Required parameter requestParameters.reason was null or undefined when calling adminDeleteManuscriptRevision.');
        }

        const queryParameters: any = {};

        if (requestParameters.reason !== undefined) {
            queryParameters['reason'] = requestParameters.reason;
        }

        if (requestParameters.additionalReason !== undefined) {
            queryParameters['additionalReason'] = requestParameters.additionalReason;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/admin/manuscripts/{manuscriptId}/revisions/{revisionId}`.replace(`{${"manuscriptId"}}`, encodeURIComponent(String(requestParameters.manuscriptId))).replace(`{${"revisionId"}}`, encodeURIComponent(String(requestParameters.revisionId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * deletes the manuscript with the given id (dangerous - does not check ownership)
     */
    async adminDeleteManuscriptRevision(requestParameters: AdminDeleteManuscriptRevisionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.adminDeleteManuscriptRevisionRaw(requestParameters, initOverrides);
    }

    /**
     * returns the analyzed data for a revision
     */
    async adminGetAnalyzedDataRaw(requestParameters: AdminGetAnalyzedDataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ModelResultData>>> {
        if (requestParameters.manuscriptId === null || requestParameters.manuscriptId === undefined) {
            throw new runtime.RequiredError('manuscriptId','Required parameter requestParameters.manuscriptId was null or undefined when calling adminGetAnalyzedData.');
        }

        if (requestParameters.revisionId === null || requestParameters.revisionId === undefined) {
            throw new runtime.RequiredError('revisionId','Required parameter requestParameters.revisionId was null or undefined when calling adminGetAnalyzedData.');
        }

        const queryParameters: any = {};

        if (requestParameters.models !== undefined) {
            queryParameters['models'] = requestParameters.models;
        }

        if (requestParameters.sections !== undefined) {
            queryParameters['sections'] = requestParameters.sections;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/admin/manuscripts/{manuscriptId}/revisions/{revisionId}/`.replace(`{${"manuscriptId"}}`, encodeURIComponent(String(requestParameters.manuscriptId))).replace(`{${"revisionId"}}`, encodeURIComponent(String(requestParameters.revisionId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * returns the analyzed data for a revision
     */
    async adminGetAnalyzedData(requestParameters: AdminGetAnalyzedDataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ModelResultData>> {
        const response = await this.adminGetAnalyzedDataRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * gets a specific author
     */
    async adminGetAuthorRaw(requestParameters: AdminGetAuthorRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Author>> {
        if (requestParameters.authorId === null || requestParameters.authorId === undefined) {
            throw new runtime.RequiredError('authorId','Required parameter requestParameters.authorId was null or undefined when calling adminGetAuthor.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/admin/authors/{authorId}/`.replace(`{${"authorId"}}`, encodeURIComponent(String(requestParameters.authorId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * gets a specific author
     */
    async adminGetAuthor(requestParameters: AdminGetAuthorRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Author> {
        const response = await this.adminGetAuthorRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * lists of events for an author
     */
    async adminGetAuthorHistoryRaw(requestParameters: AdminGetAuthorHistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PageOfDetailedHistoryEvent>> {
        if (requestParameters.authorId === null || requestParameters.authorId === undefined) {
            throw new runtime.RequiredError('authorId','Required parameter requestParameters.authorId was null or undefined when calling adminGetAuthorHistory.');
        }

        const queryParameters: any = {};

        if (requestParameters.startTime !== undefined) {
            queryParameters['startTime'] = requestParameters.startTime;
        }

        if (requestParameters.endTime !== undefined) {
            queryParameters['endTime'] = requestParameters.endTime;
        }

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['pageSize'] = requestParameters.pageSize;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/admin/authors/{authorId}/history/`.replace(`{${"authorId"}}`, encodeURIComponent(String(requestParameters.authorId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * lists of events for an author
     */
    async adminGetAuthorHistory(requestParameters: AdminGetAuthorHistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PageOfDetailedHistoryEvent> {
        const response = await this.adminGetAuthorHistoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * lists authors
     */
    async adminGetAuthorsRaw(requestParameters: AdminGetAuthorsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PageOfAuthor>> {
        const queryParameters: any = {};

        if (requestParameters.email !== undefined) {
            queryParameters['email'] = requestParameters.email;
        }

        if (requestParameters.roles !== undefined) {
            queryParameters['roles'] = requestParameters.roles;
        }

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['pageSize'] = requestParameters.pageSize;
        }

        if (requestParameters.sortBy !== undefined) {
            queryParameters['sortBy'] = requestParameters.sortBy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/admin/authors/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * lists authors
     */
    async adminGetAuthors(requestParameters: AdminGetAuthorsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PageOfAuthor> {
        const response = await this.adminGetAuthorsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * lists manuscript revisions
     */
    async adminGetManuscriptRevisionsRaw(requestParameters: AdminGetManuscriptRevisionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PageOfManuscriptRevision>> {
        if (requestParameters.manuscriptId === null || requestParameters.manuscriptId === undefined) {
            throw new runtime.RequiredError('manuscriptId','Required parameter requestParameters.manuscriptId was null or undefined when calling adminGetManuscriptRevisions.');
        }

        const queryParameters: any = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['pageSize'] = requestParameters.pageSize;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/admin/manuscripts/{manuscriptId}/revisions/`.replace(`{${"manuscriptId"}}`, encodeURIComponent(String(requestParameters.manuscriptId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * lists manuscript revisions
     */
    async adminGetManuscriptRevisions(requestParameters: AdminGetManuscriptRevisionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PageOfManuscriptRevision> {
        const response = await this.adminGetManuscriptRevisionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * return all manuscripts (optionally limit to specific author)
     */
    async adminGetManuscriptsRaw(requestParameters: AdminGetManuscriptsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PageOfManuscript>> {
        const queryParameters: any = {};

        if (requestParameters.authorId !== undefined) {
            queryParameters['authorId'] = requestParameters.authorId;
        }

        if (requestParameters.sortBy !== undefined) {
            queryParameters['sortBy'] = requestParameters.sortBy;
        }

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['pageSize'] = requestParameters.pageSize;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/admin/manuscripts/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * return all manuscripts (optionally limit to specific author)
     */
    async adminGetManuscripts(requestParameters: AdminGetManuscriptsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PageOfManuscript> {
        const response = await this.adminGetManuscriptsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * change the role for an author
     */
    async adminSetRoleRaw(requestParameters: AdminSetRoleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.authorId === null || requestParameters.authorId === undefined) {
            throw new runtime.RequiredError('authorId','Required parameter requestParameters.authorId was null or undefined when calling adminSetRole.');
        }

        if (requestParameters.newRole === null || requestParameters.newRole === undefined) {
            throw new runtime.RequiredError('newRole','Required parameter requestParameters.newRole was null or undefined when calling adminSetRole.');
        }

        const queryParameters: any = {};

        if (requestParameters.newRole !== undefined) {
            queryParameters['newRole'] = requestParameters.newRole;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/admin/authors/{authorId}/role`.replace(`{${"authorId"}}`, encodeURIComponent(String(requestParameters.authorId))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * change the role for an author
     */
    async adminSetRole(requestParameters: AdminSetRoleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.adminSetRoleRaw(requestParameters, initOverrides);
    }

    /**
     * Change the title of a manuscript revision
     */
    async changeManuscriptRevisionTitleRaw(requestParameters: ChangeManuscriptRevisionTitleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.manuscriptId === null || requestParameters.manuscriptId === undefined) {
            throw new runtime.RequiredError('manuscriptId','Required parameter requestParameters.manuscriptId was null or undefined when calling changeManuscriptRevisionTitle.');
        }

        if (requestParameters.revisionId === null || requestParameters.revisionId === undefined) {
            throw new runtime.RequiredError('revisionId','Required parameter requestParameters.revisionId was null or undefined when calling changeManuscriptRevisionTitle.');
        }

        if (requestParameters.newTitle === null || requestParameters.newTitle === undefined) {
            throw new runtime.RequiredError('newTitle','Required parameter requestParameters.newTitle was null or undefined when calling changeManuscriptRevisionTitle.');
        }

        const queryParameters: any = {};

        if (requestParameters.newTitle !== undefined) {
            queryParameters['newTitle'] = requestParameters.newTitle;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/manuscripts/{manuscriptId}/revisions/{revisionId}/title`.replace(`{${"manuscriptId"}}`, encodeURIComponent(String(requestParameters.manuscriptId))).replace(`{${"revisionId"}}`, encodeURIComponent(String(requestParameters.revisionId))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Change the title of a manuscript revision
     */
    async changeManuscriptRevisionTitle(requestParameters: ChangeManuscriptRevisionTitleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.changeManuscriptRevisionTitleRaw(requestParameters, initOverrides);
    }

    /**
     * Change the title of a manuscript
     */
    async changeManuscriptTitleRaw(requestParameters: ChangeManuscriptTitleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.manuscriptId === null || requestParameters.manuscriptId === undefined) {
            throw new runtime.RequiredError('manuscriptId','Required parameter requestParameters.manuscriptId was null or undefined when calling changeManuscriptTitle.');
        }

        if (requestParameters.newTitle === null || requestParameters.newTitle === undefined) {
            throw new runtime.RequiredError('newTitle','Required parameter requestParameters.newTitle was null or undefined when calling changeManuscriptTitle.');
        }

        const queryParameters: any = {};

        if (requestParameters.newTitle !== undefined) {
            queryParameters['newTitle'] = requestParameters.newTitle;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/manuscripts/{manuscriptId}/title`.replace(`{${"manuscriptId"}}`, encodeURIComponent(String(requestParameters.manuscriptId))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Change the title of a manuscript
     */
    async changeManuscriptTitle(requestParameters: ChangeManuscriptTitleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.changeManuscriptTitleRaw(requestParameters, initOverrides);
    }

    /**
     * creates a purchase
     */
    async createPurchaseRaw(requestParameters: CreatePurchaseRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PurchaseInitiationResult>> {
        if (requestParameters.productId === null || requestParameters.productId === undefined) {
            throw new runtime.RequiredError('productId','Required parameter requestParameters.productId was null or undefined when calling createPurchase.');
        }

        const queryParameters: any = {};

        if (requestParameters.productId !== undefined) {
            queryParameters['productId'] = requestParameters.productId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/payment/purchase/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * creates a purchase
     */
    async createPurchase(requestParameters: CreatePurchaseRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PurchaseInitiationResult> {
        const response = await this.createPurchaseRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * deletes the manuscript with the given id (if the logged-in user is owner)
     */
    async deleteManuscriptRaw(requestParameters: DeleteManuscriptRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.manuscriptId === null || requestParameters.manuscriptId === undefined) {
            throw new runtime.RequiredError('manuscriptId','Required parameter requestParameters.manuscriptId was null or undefined when calling deleteManuscript.');
        }

        if (requestParameters.reason === null || requestParameters.reason === undefined) {
            throw new runtime.RequiredError('reason','Required parameter requestParameters.reason was null or undefined when calling deleteManuscript.');
        }

        const queryParameters: any = {};

        if (requestParameters.reason !== undefined) {
            queryParameters['reason'] = requestParameters.reason;
        }

        if (requestParameters.additionalReason !== undefined) {
            queryParameters['additionalReason'] = requestParameters.additionalReason;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/manuscripts/{manuscriptId}`.replace(`{${"manuscriptId"}}`, encodeURIComponent(String(requestParameters.manuscriptId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * deletes the manuscript with the given id (if the logged-in user is owner)
     */
    async deleteManuscript(requestParameters: DeleteManuscriptRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteManuscriptRaw(requestParameters, initOverrides);
    }

    /**
     * deletes the manuscript revision with the given ids (if the logged-in user is owner)
     */
    async deleteManuscriptRevisionRaw(requestParameters: DeleteManuscriptRevisionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.manuscriptId === null || requestParameters.manuscriptId === undefined) {
            throw new runtime.RequiredError('manuscriptId','Required parameter requestParameters.manuscriptId was null or undefined when calling deleteManuscriptRevision.');
        }

        if (requestParameters.revisionId === null || requestParameters.revisionId === undefined) {
            throw new runtime.RequiredError('revisionId','Required parameter requestParameters.revisionId was null or undefined when calling deleteManuscriptRevision.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/manuscripts/{manuscriptId}/revisions/{revisionId}`.replace(`{${"manuscriptId"}}`, encodeURIComponent(String(requestParameters.manuscriptId))).replace(`{${"revisionId"}}`, encodeURIComponent(String(requestParameters.revisionId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * deletes the manuscript revision with the given ids (if the logged-in user is owner)
     */
    async deleteManuscriptRevision(requestParameters: DeleteManuscriptRevisionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteManuscriptRevisionRaw(requestParameters, initOverrides);
    }

    /**
     * deletes a specific setting for the logged-in user
     */
    async deleteSettingRaw(requestParameters: DeleteSettingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteSetting.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/author/settings/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * deletes a specific setting for the logged-in user
     */
    async deleteSetting(requestParameters: DeleteSettingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteSettingRaw(requestParameters, initOverrides);
    }

    /**
     * deletes all settings for the logged-in user
     */
    async deleteSettingsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/author/settings/`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * deletes all settings for the logged-in user
     */
    async deleteSettings(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteSettingsRaw(initOverrides);
    }

    /**
     * deletes all settings for the logged-in user
     */
    async deleteTextRaw(requestParameters: DeleteTextRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.language === null || requestParameters.language === undefined) {
            throw new runtime.RequiredError('language','Required parameter requestParameters.language was null or undefined when calling deleteText.');
        }

        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteText.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/admin/texts/{language}/{name}`.replace(`{${"language"}}`, encodeURIComponent(String(requestParameters.language))).replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * deletes all settings for the logged-in user
     */
    async deleteText(requestParameters: DeleteTextRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteTextRaw(requestParameters, initOverrides);
    }

    /**
     * returns payment products
     */
    async getAdminPaymentProductsRaw(requestParameters: GetAdminPaymentProductsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PageOfAdminPaymentProduct>> {
        const queryParameters: any = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['pageSize'] = requestParameters.pageSize;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/admin/payment/products/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * returns payment products
     */
    async getAdminPaymentProducts(requestParameters: GetAdminPaymentProductsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PageOfAdminPaymentProduct> {
        const response = await this.getAdminPaymentProductsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * returns the analyzed data for a revision
     */
    async getAnalyzedDataRaw(requestParameters: GetAnalyzedDataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ModelResultData>>> {
        if (requestParameters.manuscriptId === null || requestParameters.manuscriptId === undefined) {
            throw new runtime.RequiredError('manuscriptId','Required parameter requestParameters.manuscriptId was null or undefined when calling getAnalyzedData.');
        }

        if (requestParameters.revisionId === null || requestParameters.revisionId === undefined) {
            throw new runtime.RequiredError('revisionId','Required parameter requestParameters.revisionId was null or undefined when calling getAnalyzedData.');
        }

        const queryParameters: any = {};

        if (requestParameters.models !== undefined) {
            queryParameters['models'] = requestParameters.models;
        }

        if (requestParameters.sections !== undefined) {
            queryParameters['sections'] = requestParameters.sections;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/manuscripts/{manuscriptId}/revisions/{revisionId}/`.replace(`{${"manuscriptId"}}`, encodeURIComponent(String(requestParameters.manuscriptId))).replace(`{${"revisionId"}}`, encodeURIComponent(String(requestParameters.revisionId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * returns the analyzed data for a revision
     */
    async getAnalyzedData(requestParameters: GetAnalyzedDataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ModelResultData>> {
        const response = await this.getAnalyzedDataRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * gets archetypeIndexes
     */
    async getArchetypeIndexesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ArchetypeIndex>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/archetypeIndexes/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * gets archetypeIndexes
     */
    async getArchetypeIndexes(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ArchetypeIndex>> {
        const response = await this.getArchetypeIndexesRaw(initOverrides);
        return await response.value();
    }

    /**
     * gets archetypes
     */
    async getArchetypesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Archetype>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/archetypes/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * gets archetypes
     */
    async getArchetypes(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Archetype>> {
        const response = await this.getArchetypesRaw(initOverrides);
        return await response.value();
    }

    /**
     * gets Articles
     */
    async getArticlesRaw(requestParameters: GetArticlesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Article>>> {
        if (requestParameters.report === null || requestParameters.report === undefined) {
            throw new runtime.RequiredError('report','Required parameter requestParameters.report was null or undefined when calling getArticles.');
        }

        const queryParameters: any = {};

        if (requestParameters.report !== undefined) {
            queryParameters['report'] = requestParameters.report;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/articles/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * gets Articles
     */
    async getArticles(requestParameters: GetArticlesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Article>> {
        const response = await this.getArticlesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * return info about the current user
     */
    async getAuthorStatusRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AuthorStatus>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/author/status`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * return info about the current user
     */
    async getAuthorStatus(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AuthorStatus> {
        const response = await this.getAuthorStatusRaw(initOverrides);
        return await response.value();
    }

    /**
     * returns the genres and audiences
     */
    async getCategoriesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CategoryInfo>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/info/categories`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * returns the genres and audiences
     */
    async getCategories(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CategoryInfo> {
        const response = await this.getCategoriesRaw(initOverrides);
        return await response.value();
    }

    /**
     * gets Characteristic
     */
    async getCharacteristicRaw(requestParameters: GetCharacteristicRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Characteristic>>> {
        if (requestParameters.report === null || requestParameters.report === undefined) {
            throw new runtime.RequiredError('report','Required parameter requestParameters.report was null or undefined when calling getCharacteristic.');
        }

        const queryParameters: any = {};

        if (requestParameters.report !== undefined) {
            queryParameters['report'] = requestParameters.report;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/characteristics/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * gets Characteristic
     */
    async getCharacteristic(requestParameters: GetCharacteristicRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Characteristic>> {
        const response = await this.getCharacteristicRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async getDashboardRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Dashboard>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/dashboard/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     */
    async getDashboard(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Dashboard>> {
        const response = await this.getDashboardRaw(initOverrides);
        return await response.value();
    }

    /**
     * returns payment products
     */
    async getEligiblePaymentProductsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<PaymentProduct>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/payment/products/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * returns payment products
     */
    async getEligiblePaymentProducts(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<PaymentProduct>> {
        const response = await this.getEligiblePaymentProductsRaw(initOverrides);
        return await response.value();
    }

    /**
     * lists authors
     */
    async getEnginesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<EngineInfo>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/admin/engines/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * lists authors
     */
    async getEngines(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<EngineInfo>> {
        const response = await this.getEnginesRaw(initOverrides);
        return await response.value();
    }

    /**
     * gets globalscores
     */
    async getGlobalscoresRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<GlobalScore>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/globalScores/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * gets globalscores
     */
    async getGlobalscores(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<GlobalScore>> {
        const response = await this.getGlobalscoresRaw(initOverrides);
        return await response.value();
    }

    /**
     * lists of events for the author
     */
    async getHistoryRaw(requestParameters: GetHistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PageOfHistoryEvent>> {
        const queryParameters: any = {};

        if (requestParameters.startTime !== undefined) {
            queryParameters['startTime'] = requestParameters.startTime;
        }

        if (requestParameters.endTime !== undefined) {
            queryParameters['endTime'] = requestParameters.endTime;
        }

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['pageSize'] = requestParameters.pageSize;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/author/history/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * lists of events for the author
     */
    async getHistory(requestParameters: GetHistoryRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PageOfHistoryEvent> {
        const response = await this.getHistoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async getInfosRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Info>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/infos/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     */
    async getInfos(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Info>> {
        const response = await this.getInfosRaw(initOverrides);
        return await response.value();
    }

    /**
     * lists of invoices for the author
     */
    async getInvoicesRaw(requestParameters: GetInvoicesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PageOfInvoice>> {
        const queryParameters: any = {};

        if (requestParameters.type !== undefined) {
            queryParameters['type'] = requestParameters.type;
        }

        if (requestParameters.startTime !== undefined) {
            queryParameters['startTime'] = requestParameters.startTime;
        }

        if (requestParameters.endTime !== undefined) {
            queryParameters['endTime'] = requestParameters.endTime;
        }

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['pageSize'] = requestParameters.pageSize;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/author/invoices/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * lists of invoices for the author
     */
    async getInvoices(requestParameters: GetInvoicesRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PageOfInvoice> {
        const response = await this.getInvoicesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * returns an estimation of the lowest queue number
     */
    async getLowestQueueNumberRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<number>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/info/lowest-queue-number`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<number>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * returns an estimation of the lowest queue number
     */
    async getLowestQueueNumber(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<number> {
        const response = await this.getLowestQueueNumberRaw(initOverrides);
        return await response.value();
    }

    /**
     * lists manuscript revisions for the current user
     */
    async getManuscriptRevisionsRaw(requestParameters: GetManuscriptRevisionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PageOfManuscriptRevision>> {
        if (requestParameters.manuscriptId === null || requestParameters.manuscriptId === undefined) {
            throw new runtime.RequiredError('manuscriptId','Required parameter requestParameters.manuscriptId was null or undefined when calling getManuscriptRevisions.');
        }

        const queryParameters: any = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['pageSize'] = requestParameters.pageSize;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/manuscripts/{manuscriptId}/revisions/`.replace(`{${"manuscriptId"}}`, encodeURIComponent(String(requestParameters.manuscriptId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * lists manuscript revisions for the current user
     */
    async getManuscriptRevisions(requestParameters: GetManuscriptRevisionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PageOfManuscriptRevision> {
        const response = await this.getManuscriptRevisionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * lists manuscripts for the current user
     */
    async getManuscriptsRaw(requestParameters: GetManuscriptsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PageOfManuscript>> {
        const queryParameters: any = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['pageSize'] = requestParameters.pageSize;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/manuscripts/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * lists manuscripts for the current user
     */
    async getManuscripts(requestParameters: GetManuscriptsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PageOfManuscript> {
        const response = await this.getManuscriptsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * returns a purchase
     */
    async getPurchaseRaw(requestParameters: GetPurchaseRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Purchase>> {
        if (requestParameters.clientReferenceId === null || requestParameters.clientReferenceId === undefined) {
            throw new runtime.RequiredError('clientReferenceId','Required parameter requestParameters.clientReferenceId was null or undefined when calling getPurchase.');
        }

        const queryParameters: any = {};

        if (requestParameters.clientReferenceId !== undefined) {
            queryParameters['clientReferenceId'] = requestParameters.clientReferenceId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/payment/purchase/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * returns a purchase
     */
    async getPurchase(requestParameters: GetPurchaseRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Purchase> {
        const response = await this.getPurchaseRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * lists of purchases for the author
     */
    async getPurchasesRaw(requestParameters: GetPurchasesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PageOfPurchase>> {
        const queryParameters: any = {};

        if (requestParameters.status !== undefined) {
            queryParameters['status'] = requestParameters.status;
        }

        if (requestParameters.productType !== undefined) {
            queryParameters['productType'] = requestParameters.productType;
        }

        if (requestParameters.startTime !== undefined) {
            queryParameters['startTime'] = requestParameters.startTime;
        }

        if (requestParameters.endTime !== undefined) {
            queryParameters['endTime'] = requestParameters.endTime;
        }

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['pageSize'] = requestParameters.pageSize;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/author/purchases/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * lists of purchases for the author
     */
    async getPurchases(requestParameters: GetPurchasesRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PageOfPurchase> {
        const response = await this.getPurchasesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * gets a recommendation
     */
    async getRecommendationRaw(requestParameters: GetRecommendationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Recommendation>> {
        if (requestParameters.metricId === null || requestParameters.metricId === undefined) {
            throw new runtime.RequiredError('metricId','Required parameter requestParameters.metricId was null or undefined when calling getRecommendation.');
        }

        if (requestParameters.genre === null || requestParameters.genre === undefined) {
            throw new runtime.RequiredError('genre','Required parameter requestParameters.genre was null or undefined when calling getRecommendation.');
        }

        if (requestParameters.audience === null || requestParameters.audience === undefined) {
            throw new runtime.RequiredError('audience','Required parameter requestParameters.audience was null or undefined when calling getRecommendation.');
        }

        if (requestParameters.metricValue === null || requestParameters.metricValue === undefined) {
            throw new runtime.RequiredError('metricValue','Required parameter requestParameters.metricValue was null or undefined when calling getRecommendation.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/recommendations/{metricId}/{genre}/{audience}/{metricValue}`.replace(`{${"metricId"}}`, encodeURIComponent(String(requestParameters.metricId))).replace(`{${"genre"}}`, encodeURIComponent(String(requestParameters.genre))).replace(`{${"audience"}}`, encodeURIComponent(String(requestParameters.audience))).replace(`{${"metricValue"}}`, encodeURIComponent(String(requestParameters.metricValue))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * gets a recommendation
     */
    async getRecommendation(requestParameters: GetRecommendationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Recommendation> {
        const response = await this.getRecommendationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * gets ReportIndexes
     */
    async getReportIndexesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ReportIndex>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/reportIndexes/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * gets ReportIndexes
     */
    async getReportIndexes(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ReportIndex>> {
        const response = await this.getReportIndexesRaw(initOverrides);
        return await response.value();
    }

    /**
     * returns currently logged-in users settings
     */
    async getSettingsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<AuthorSetting>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/author/settings/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * returns currently logged-in users settings
     */
    async getSettings(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<AuthorSetting>> {
        const response = await this.getSettingsRaw(initOverrides);
        return await response.value();
    }

    /**
     * returns the analyzed data for a similar book
     */
    async getSimilarBookDataRaw(requestParameters: GetSimilarBookDataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ModelResultData>>> {
        if (requestParameters.isbn === null || requestParameters.isbn === undefined) {
            throw new runtime.RequiredError('isbn','Required parameter requestParameters.isbn was null or undefined when calling getSimilarBookData.');
        }

        const queryParameters: any = {};

        if (requestParameters.models !== undefined) {
            queryParameters['models'] = requestParameters.models;
        }

        if (requestParameters.sections !== undefined) {
            queryParameters['sections'] = requestParameters.sections;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/similar-books/{isbn}`.replace(`{${"isbn"}}`, encodeURIComponent(String(requestParameters.isbn))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * returns the analyzed data for a similar book
     */
    async getSimilarBookData(requestParameters: GetSimilarBookDataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ModelResultData>> {
        const response = await this.getSimilarBookDataRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * returns the matedata data for a similar book
     */
    async getSimilarBookMetadataRaw(requestParameters: GetSimilarBookMetadataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SimilarBookMetadata>> {
        if (requestParameters.isbn === null || requestParameters.isbn === undefined) {
            throw new runtime.RequiredError('isbn','Required parameter requestParameters.isbn was null or undefined when calling getSimilarBookMetadata.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/similar-books/{isbn}/metadata`.replace(`{${"isbn"}}`, encodeURIComponent(String(requestParameters.isbn))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * returns the matedata data for a similar book
     */
    async getSimilarBookMetadata(requestParameters: GetSimilarBookMetadataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SimilarBookMetadata> {
        const response = await this.getSimilarBookMetadataRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * returns the analyzed data for a similar book
     */
    async getSimilarBookTrialReportDataRaw(requestParameters: GetSimilarBookTrialReportDataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ModelResultData>>> {
        const queryParameters: any = {};

        if (requestParameters.models !== undefined) {
            queryParameters['models'] = requestParameters.models;
        }

        if (requestParameters.sections !== undefined) {
            queryParameters['sections'] = requestParameters.sections;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/trial-report/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * returns the analyzed data for a similar book
     */
    async getSimilarBookTrialReportData(requestParameters: GetSimilarBookTrialReportDataRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ModelResultData>> {
        const response = await this.getSimilarBookTrialReportDataRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * returns the matedata data for a similar book
     */
    async getSimilarBookTrialReportMetadataRaw(requestParameters: GetSimilarBookTrialReportMetadataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SimilarBookMetadata>> {
        if (requestParameters.isbn === null || requestParameters.isbn === undefined) {
            throw new runtime.RequiredError('isbn','Required parameter requestParameters.isbn was null or undefined when calling getSimilarBookTrialReportMetadata.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/trial-report/metadata`.replace(`{${"isbn"}}`, encodeURIComponent(String(requestParameters.isbn))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * returns the matedata data for a similar book
     */
    async getSimilarBookTrialReportMetadata(requestParameters: GetSimilarBookTrialReportMetadataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SimilarBookMetadata> {
        const response = await this.getSimilarBookTrialReportMetadataRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * lists of subscriptions for the author
     */
    async getSubscriptionsRaw(requestParameters: GetSubscriptionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PageOfSubscription>> {
        const queryParameters: any = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['pageSize'] = requestParameters.pageSize;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/author/subscriptions/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * lists of subscriptions for the author
     */
    async getSubscriptions(requestParameters: GetSubscriptionsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PageOfSubscription> {
        const response = await this.getSubscriptionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * returns texts
     */
    async getTextsRaw(requestParameters: GetTextsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Text>>> {
        if (requestParameters.language === null || requestParameters.language === undefined) {
            throw new runtime.RequiredError('language','Required parameter requestParameters.language was null or undefined when calling getTexts.');
        }

        const queryParameters: any = {};

        if (requestParameters.names !== undefined) {
            queryParameters['names'] = requestParameters.names;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/texts/{language}/`.replace(`{${"language"}}`, encodeURIComponent(String(requestParameters.language))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * returns texts
     */
    async getTexts(requestParameters: GetTextsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Text>> {
        const response = await this.getTextsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * gets tips
     */
    async getTipsRaw(requestParameters: GetTipsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Tip>>> {
        if (requestParameters.report === null || requestParameters.report === undefined) {
            throw new runtime.RequiredError('report','Required parameter requestParameters.report was null or undefined when calling getTips.');
        }

        const queryParameters: any = {};

        if (requestParameters.report !== undefined) {
            queryParameters['report'] = requestParameters.report;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/tips/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * gets tips
     */
    async getTips(requestParameters: GetTipsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Tip>> {
        const response = await this.getTipsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async getwhatIsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<WhatIs>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/whatis/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     */
    async getwhatIs(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<WhatIs>> {
        const response = await this.getwhatIsRaw(initOverrides);
        return await response.value();
    }

    /**
     */
    async savePaymentProductRaw(requestParameters: SavePaymentProductRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/admin/payment/products/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.adminPaymentProduct,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async savePaymentProduct(requestParameters: SavePaymentProductRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.savePaymentProductRaw(requestParameters, initOverrides);
    }

    /**
     * saves settings logged-in user
     */
    async saveSettingsRaw(requestParameters: SaveSettingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/author/settings/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.authorSetting,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * saves settings logged-in user
     */
    async saveSettings(requestParameters: SaveSettingsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.saveSettingsRaw(requestParameters, initOverrides);
    }

    /**
     * saves a text (create if doesn\'t exist)
     */
    async saveTextRaw(requestParameters: SaveTextRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.language === null || requestParameters.language === undefined) {
            throw new runtime.RequiredError('language','Required parameter requestParameters.language was null or undefined when calling saveText.');
        }

        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling saveText.');
        }

        if (requestParameters.text === null || requestParameters.text === undefined) {
            throw new runtime.RequiredError('text','Required parameter requestParameters.text was null or undefined when calling saveText.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const consumes: runtime.Consume[] = [
            { contentType: 'application/x-www-form-urlencoded' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters.text !== undefined) {
            formParams.append('text', requestParameters.text as any);
        }

        const response = await this.request({
            path: `/api/admin/texts/{language}/{name}`.replace(`{${"language"}}`, encodeURIComponent(String(requestParameters.language))).replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * saves a text (create if doesn\'t exist)
     */
    async saveText(requestParameters: SaveTextRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.saveTextRaw(requestParameters, initOverrides);
    }

    /**
     * provide the users email (if not provided by auth0) - note will be overwritten by the value from auth0 if auth0 provides one.
     */
    async setAuthorEmailRaw(requestParameters: SetAuthorEmailRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.email === null || requestParameters.email === undefined) {
            throw new runtime.RequiredError('email','Required parameter requestParameters.email was null or undefined when calling setAuthorEmail.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const consumes: runtime.Consume[] = [
            { contentType: 'application/x-www-form-urlencoded' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters.email !== undefined) {
            formParams.append('email', requestParameters.email as any);
        }

        const response = await this.request({
            path: `/api/author/email`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * provide the users email (if not provided by auth0) - note will be overwritten by the value from auth0 if auth0 provides one.
     */
    async setAuthorEmail(requestParameters: SetAuthorEmailRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.setAuthorEmailRaw(requestParameters, initOverrides);
    }

    /**
     * Upload a manuscript
     */
    async uploadManuscriptRaw(requestParameters: UploadManuscriptRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ManuscriptUploadResponse>> {
        if (requestParameters.manuscriptTitle === null || requestParameters.manuscriptTitle === undefined) {
            throw new runtime.RequiredError('manuscriptTitle','Required parameter requestParameters.manuscriptTitle was null or undefined when calling uploadManuscript.');
        }

        if (requestParameters.targetAudience === null || requestParameters.targetAudience === undefined) {
            throw new runtime.RequiredError('targetAudience','Required parameter requestParameters.targetAudience was null or undefined when calling uploadManuscript.');
        }

        if (requestParameters.targetGenre === null || requestParameters.targetGenre === undefined) {
            throw new runtime.RequiredError('targetGenre','Required parameter requestParameters.targetGenre was null or undefined when calling uploadManuscript.');
        }

        if (requestParameters.fileType === null || requestParameters.fileType === undefined) {
            throw new runtime.RequiredError('fileType','Required parameter requestParameters.fileType was null or undefined when calling uploadManuscript.');
        }

        if (requestParameters.file === null || requestParameters.file === undefined) {
            throw new runtime.RequiredError('file','Required parameter requestParameters.file was null or undefined when calling uploadManuscript.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters.manuscriptTitle !== undefined) {
            formParams.append('manuscriptTitle', requestParameters.manuscriptTitle as any);
        }

        if (requestParameters.revisionTitle !== undefined) {
            formParams.append('revisionTitle', requestParameters.revisionTitle as any);
        }

        if (requestParameters.targetAudience !== undefined) {
            formParams.append('targetAudience', requestParameters.targetAudience as any);
        }

        if (requestParameters.targetGenre !== undefined) {
            formParams.append('targetGenre', requestParameters.targetGenre as any);
        }

        if (requestParameters.fileType !== undefined) {
            formParams.append('fileType', requestParameters.fileType as any);
        }

        if (requestParameters.file !== undefined) {
            formParams.append('file', requestParameters.file as any);
        }

        const response = await this.request({
            path: `/api/manuscripts/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Upload a manuscript
     */
    async uploadManuscript(requestParameters: UploadManuscriptRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ManuscriptUploadResponse> {
        const response = await this.uploadManuscriptRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Upload a manuscript
     */
    async uploadManuscriptRevisionRaw(requestParameters: UploadManuscriptRevisionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ManuscriptUploadResponse>> {
        if (requestParameters.manuscriptId === null || requestParameters.manuscriptId === undefined) {
            throw new runtime.RequiredError('manuscriptId','Required parameter requestParameters.manuscriptId was null or undefined when calling uploadManuscriptRevision.');
        }

        if (requestParameters.targetAudience === null || requestParameters.targetAudience === undefined) {
            throw new runtime.RequiredError('targetAudience','Required parameter requestParameters.targetAudience was null or undefined when calling uploadManuscriptRevision.');
        }

        if (requestParameters.targetGenre === null || requestParameters.targetGenre === undefined) {
            throw new runtime.RequiredError('targetGenre','Required parameter requestParameters.targetGenre was null or undefined when calling uploadManuscriptRevision.');
        }

        if (requestParameters.fileType === null || requestParameters.fileType === undefined) {
            throw new runtime.RequiredError('fileType','Required parameter requestParameters.fileType was null or undefined when calling uploadManuscriptRevision.');
        }

        if (requestParameters.file === null || requestParameters.file === undefined) {
            throw new runtime.RequiredError('file','Required parameter requestParameters.file was null or undefined when calling uploadManuscriptRevision.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters.revisionTitle !== undefined) {
            formParams.append('revisionTitle', requestParameters.revisionTitle as any);
        }

        if (requestParameters.targetAudience !== undefined) {
            formParams.append('targetAudience', requestParameters.targetAudience as any);
        }

        if (requestParameters.targetGenre !== undefined) {
            formParams.append('targetGenre', requestParameters.targetGenre as any);
        }

        if (requestParameters.fileType !== undefined) {
            formParams.append('fileType', requestParameters.fileType as any);
        }

        if (requestParameters.file !== undefined) {
            formParams.append('file', requestParameters.file as any);
        }

        const response = await this.request({
            path: `/api/manuscripts/{manuscriptId}/revisions/`.replace(`{${"manuscriptId"}}`, encodeURIComponent(String(requestParameters.manuscriptId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Upload a manuscript
     */
    async uploadManuscriptRevision(requestParameters: UploadManuscriptRevisionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ManuscriptUploadResponse> {
        const response = await this.uploadManuscriptRevisionRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
  * @export
  * @enum {string}
  */
export enum AdminGetAuthorsSortByEnum {
    Name = 'NAME',
    NameDesc = 'NAME_DESC',
    Created = 'CREATED',
    CreatedDesc = 'CREATED_DESC'
}
/**
  * @export
  * @enum {string}
  */
export enum AdminGetManuscriptsSortByEnum {
    GlobalScore = 'globalScore',
    LatestRevision = 'latestRevision'
}
/**
  * @export
  * @enum {string}
  */
export enum UploadManuscriptFileTypeEnum {
    Text = 'TEXT',
    Docx = 'DOCX',
    Epub = 'EPUB'
}
/**
  * @export
  * @enum {string}
  */
export enum UploadManuscriptRevisionFileTypeEnum {
    Text = 'TEXT',
    Docx = 'DOCX',
    Epub = 'EPUB'
}
